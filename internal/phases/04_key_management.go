package phases

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"github.com/inc4/gonka-nop/internal/config"
	"github.com/inc4/gonka-nop/internal/ui"
)

const (
	workflowSecure = "secure"
)

// KeyManagement handles key generation workflow
type KeyManagement struct {
	workflow string // "quick" or "secure"
	mocked   bool
}

// NewKeyManagement creates a new KeyManagement phase.
func NewKeyManagement(workflow string, mocked bool) *KeyManagement {
	return &KeyManagement{workflow: workflow, mocked: mocked}
}

func (p *KeyManagement) Name() string {
	return "Key Management"
}

func (p *KeyManagement) Description() string {
	return "Setting up node keys (Account, Consensus, ML Operational)"
}

func (p *KeyManagement) ShouldRun(state *config.State) bool {
	return !state.IsPhaseComplete(p.Name())
}

func (p *KeyManagement) Run(ctx context.Context, state *config.State) error {
	// If workflow not set, ask user
	workflow := p.workflow
	if workflow == "" {
		options := []string{
			"Quick Setup - Generate all keys on this machine (less secure)",
			"Secure Setup - Account key on separate machine (recommended)",
		}
		selected, err := ui.Select("Select key management workflow:", options)
		if err != nil {
			return err
		}
		if selected == options[0] {
			workflow = "quick"
		} else {
			workflow = workflowSecure
		}
	}
	state.KeyWorkflow = workflow

	if workflow == workflowSecure {
		return p.runSecureWorkflow(ctx, state)
	}
	return p.runQuickWorkflow(ctx, state)
}

func (p *KeyManagement) runQuickWorkflow(ctx context.Context, state *config.State) error {
	ui.Info("Running quick setup - all keys will be generated on this machine")
	ui.Warn("For production, consider using secure setup with cold account key")

	// Get base name
	baseName, err := ui.Input("Enter a base name for your node keys:", "gonka-node")
	if err != nil {
		return err
	}

	// Get keyring password (inferenced requires >= 8 characters)
	password, err := ui.Password("Enter keyring password (min 8 characters):")
	if err != nil {
		return err
	}
	if len(password) < 8 {
		return fmt.Errorf("keyring password must be at least 8 characters")
	}
	state.KeyringPassword = password

	if p.mocked {
		return p.runQuickMocked(state, baseName)
	}

	return p.runQuickReal(ctx, state, baseName, password)
}

func (p *KeyManagement) runQuickMocked(state *config.State, baseName string) error {
	// Generate cold key (mocked)
	err := ui.WithSpinner("Generating Cold Key (Account)", func() error {
		time.Sleep(800 * time.Millisecond)
		return nil
	})
	if err != nil {
		return err
	}
	accountPubKey := generateMockPubKey()
	state.ColdKeyName = baseName + "-cold"
	state.AccountPubKey = accountPubKey
	state.ColdKeyAddress = "gonka1mock" + hex.EncodeToString(make([]byte, 10))
	ui.Detail("Cold Key: %s", state.ColdKeyName)
	ui.Detail("Account Public Key: %s...", accountPubKey[:20])

	// Generate warm key (mocked)
	err = ui.WithSpinner("Generating Warm Key (ML Operations)", func() error {
		time.Sleep(600 * time.Millisecond)
		return nil
	})
	if err != nil {
		return err
	}
	state.KeyName = baseName + "-warm"
	state.WarmKeyAddress = "gonka1mock" + hex.EncodeToString(make([]byte, 10))
	ui.Detail("Warm Key: %s", state.KeyName)

	// Consensus key — TMKMS generates this on first start
	err = ui.WithSpinner("Consensus Key (TMKMS)", func() error {
		time.Sleep(400 * time.Millisecond)
		return nil
	})
	if err != nil {
		return err
	}
	ui.Detail("Consensus key will be generated by TMKMS on first start")

	ui.Success("All keys generated successfully")
	return nil
}

func (p *KeyManagement) runQuickReal(ctx context.Context, state *config.State, baseName, password string) error {
	// Determine image ref
	imageRef := "ghcr.io/product-science/inferenced:" + state.ImageVersion
	if state.ImageVersion == "" {
		imageRef = "ghcr.io/product-science/inferenced:" + config.DefaultImageVersion
	}

	// Pull inferenced image
	err := ui.WithSpinner("Pulling inferenced image", func() error {
		args := []string{"pull", imageRef}
		if state.UseSudo {
			return runCmdNoOutput(ctx, "sudo", append([]string{"-E", "docker"}, args...)...)
		}
		return runCmdNoOutput(ctx, "docker", args...)
	})
	if err != nil {
		return fmt.Errorf("pull inferenced image: %w", err)
	}

	// Create keyring directory
	keyringDir := filepath.Join(state.OutputDir, ".inference")
	if err := os.MkdirAll(keyringDir, 0700); err != nil {
		return fmt.Errorf("create keyring dir: %w", err)
	}
	state.KeyringDir = keyringDir

	// Create cold key
	coldKeyName := baseName + "-cold"
	var coldKey *KeyOutput
	err = ui.WithSpinner("Generating Cold Key (Account)", func() error {
		key, mnemonic, keyErr := CreateKeyViaDocker(ctx, imageRef, coldKeyName, password, keyringDir, state.UseSudo)
		if keyErr != nil {
			return keyErr
		}
		coldKey = key
		if mnemonic != "" {
			ui.Warn("SAVE YOUR MNEMONIC (cold key):")
			ui.Detail(mnemonic)
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("create cold key: %w", err)
	}
	state.ColdKeyName = coldKeyName
	state.AccountPubKey = ExtractPubKeyBase64(coldKey.PubKey)
	state.ColdKeyAddress = coldKey.Address
	ui.Detail("Cold Key: %s (%s)", coldKeyName, coldKey.Address)

	// Create warm key
	warmKeyName := baseName + "-warm"
	var warmKey *KeyOutput
	err = ui.WithSpinner("Generating Warm Key (ML Operations)", func() error {
		key, mnemonic, keyErr := CreateKeyViaDocker(ctx, imageRef, warmKeyName, password, keyringDir, state.UseSudo)
		if keyErr != nil {
			return keyErr
		}
		warmKey = key
		if mnemonic != "" {
			ui.Warn("SAVE YOUR MNEMONIC (warm key):")
			ui.Detail(mnemonic)
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("create warm key: %w", err)
	}
	state.KeyName = warmKeyName
	state.WarmKeyAddress = warmKey.Address
	ui.Detail("Warm Key: %s (%s)", warmKeyName, warmKey.Address)

	// Consensus key — TMKMS generates this on first start
	ui.Detail("Consensus key will be generated by TMKMS on first start")

	ui.Success("All keys generated successfully")
	ui.Warn("Both cold and warm key mnemonics should be stored securely offline")
	return nil
}

func (p *KeyManagement) runSecureWorkflow(ctx context.Context, state *config.State) error {
	ui.Info("Running secure setup - Account key should be on a separate machine")

	// Check if account pubkey was provided
	if state.AccountPubKey == "" {
		ui.Header("Account Key Setup")
		ui.Info("You need to provide your Account Public Key.")
		ui.Detail("Generate it on your local machine with: gonka-nop init-account")

		pubkey, err := ui.Input("Enter your Account Public Key:", "")
		if err != nil {
			return err
		}
		state.AccountPubKey = pubkey
	}

	// Get key name
	keyName, err := ui.Input("Enter a name for your server keys:", "gonka-node")
	if err != nil {
		return err
	}

	// Get keyring password (inferenced requires >= 8 characters)
	password, err := ui.Password("Enter keyring password (min 8 characters):")
	if err != nil {
		return err
	}
	if len(password) < 8 {
		return fmt.Errorf("keyring password must be at least 8 characters")
	}
	state.KeyringPassword = password

	if p.mocked {
		return p.runSecureMocked(state, keyName)
	}

	return p.runSecureReal(ctx, state, keyName, password)
}

func (p *KeyManagement) runSecureMocked(state *config.State, keyName string) error {
	// Generate warm key only (mocked)
	err := ui.WithSpinner("Generating Warm Key (ML Operations)", func() error {
		time.Sleep(600 * time.Millisecond)
		return nil
	})
	if err != nil {
		return err
	}
	state.KeyName = keyName + "-warm"
	state.WarmKeyAddress = "gonka1mock" + hex.EncodeToString(make([]byte, 10))
	ui.Detail("Warm Key: %s", state.KeyName)

	// Consensus key
	err = ui.WithSpinner("Consensus Key (TMKMS)", func() error {
		time.Sleep(400 * time.Millisecond)
		return nil
	})
	if err != nil {
		return err
	}
	ui.Detail("Consensus key will be generated by TMKMS on first start")

	ui.Success("Server keys generated successfully")
	ui.Info("Register your node using your Account Key on your local machine")
	return nil
}

func (p *KeyManagement) runSecureReal(ctx context.Context, state *config.State, keyName, password string) error {
	imageRef := "ghcr.io/product-science/inferenced:" + state.ImageVersion
	if state.ImageVersion == "" {
		imageRef = "ghcr.io/product-science/inferenced:" + config.DefaultImageVersion
	}

	// Pull image
	err := ui.WithSpinner("Pulling inferenced image", func() error {
		args := []string{"pull", imageRef}
		if state.UseSudo {
			return runCmdNoOutput(ctx, "sudo", append([]string{"-E", "docker"}, args...)...)
		}
		return runCmdNoOutput(ctx, "docker", args...)
	})
	if err != nil {
		return fmt.Errorf("pull inferenced image: %w", err)
	}

	// Create keyring directory
	keyringDir := filepath.Join(state.OutputDir, ".inference")
	if err := os.MkdirAll(keyringDir, 0700); err != nil {
		return fmt.Errorf("create keyring dir: %w", err)
	}
	state.KeyringDir = keyringDir

	// Create warm key only
	warmKeyName := keyName + "-warm"
	var warmKey *KeyOutput
	err = ui.WithSpinner("Generating Warm Key (ML Operations)", func() error {
		key, mnemonic, keyErr := CreateKeyViaDocker(ctx, imageRef, warmKeyName, password, keyringDir, state.UseSudo)
		if keyErr != nil {
			return keyErr
		}
		warmKey = key
		if mnemonic != "" {
			ui.Warn("SAVE YOUR MNEMONIC (warm key):")
			ui.Detail(mnemonic)
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("create warm key: %w", err)
	}
	state.KeyName = warmKeyName
	state.WarmKeyAddress = warmKey.Address
	ui.Detail("Warm Key: %s (%s)", warmKeyName, warmKey.Address)

	ui.Detail("Consensus key will be generated by TMKMS on first start")

	ui.Success("Server keys generated successfully")
	ui.Info("Register your node using your Account Key on your local machine")
	return nil
}

// generateMockPubKey generates a mock public key for demo
func generateMockPubKey() string {
	bytes := make([]byte, 32)
	_, _ = rand.Read(bytes)
	return "gonkapub1" + hex.EncodeToString(bytes)[:40]
}

// runCmdNoOutput executes a command and discards output, returning only error.
func runCmdNoOutput(ctx context.Context, name string, args ...string) error {
	cmdCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
	defer cancel()
	cmd := exec.CommandContext(cmdCtx, name, args...) // #nosec G204 - args constructed internally
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("%s %s: %w\n%s", name, args[0], err, string(out))
	}
	return nil
}
